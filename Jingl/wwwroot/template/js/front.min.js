$(document).ready(function () { $("#Search").on({ click: function () { $(".box-search").toggleClass("search-visible") } }) }), $(function () { "use strict"; var o = $("body"); o.on("keyup", ".otp-num", function (t) { var i = t.which, s = $(t.target).next(".otp-num"); return 9 != i && (i < 48 || 57 < i) ? (t.preventDefault(), !1) : 9 === i || (s && s.length || (s = o.find(".otp-num").eq(0)), void s.select().focus()) }), o.on("keydown", ".otp-num", function (t) { var i = t.which; return 9 === i || 48 <= i && i <= 57 || (t.preventDefault(), !1) }), o.on("click", ".otp-num", function (t) { $(t.target).select() }) }); var handlePieAndDonutChart = function () { "use strict"; var i = [{ label: "Travel", value: 14, color: COLOR_PURPLE }, { label: "Food & Beverages", value: 36, color: COLOR_RED }, { label: "Beauty", value: 50, color: COLOR_BLUE }]; nv.addGraph(function () { var t = nv.models.pieChart().x(function (t) { return t.label }).y(function (t) { return t.value }).showLabels(!0).labelThreshold(.05).labelType("percent").donut(!0).donutRatio(.35); return d3.select("#nv-donut-chart").append("svg").datum(i).transition().duration(350).call(t), t }) }, ChartNvd3 = function () { "use strict"; return { init: function () { handlePieAndDonutChart() } } }(); function responseMessage(t) { $(".success-box").fadeIn(200), $(".success-box div.text-message").html("<span>" + t + "</span>") } $(document).ready(function () { $("#stars li").on("mouseover", function () { var i = parseInt($(this).data("value"), 10); $(this).parent().children("li.star").each(function (t) { t < i ? $(this).addClass("hover") : $(this).removeClass("hover") }) }).on("mouseout", function () { $(this).parent().children("li.star").each(function (t) { $(this).removeClass("hover") }) }) }), $(document).ready(function () { var l = Math.PI / 180, p = (Math.PI, [["#df0049", "#660671"], ["#00e857", "#005291"], ["#2bebbc", "#05798a"], ["#ffd200", "#b06c00"]]); function u(t, i) { this.x = t, this.y = i, this.Length = function () { return Math.sqrt(this.SqrLength()) }, this.SqrLength = function () { return this.x * this.x + this.y * this.y }, this.Equals = function (t, i) { return t.x == i.x && t.y == i.y }, this.Add = function (t) { this.x += t.x, this.y += t.y }, this.Sub = function (t) { this.x -= t.x, this.y -= t.y }, this.Div = function (t) { this.x /= t, this.y /= t }, this.Mul = function (t) { this.x *= t, this.y *= t }, this.Normalize = function () { var t = this.SqrLength(); if (0 != t) { var i = 1 / Math.sqrt(t); this.x *= i, this.y *= i } }, this.Normalized = function () { var t = this.SqrLength(); if (0 == t) return new u(0, 0); var i = 1 / Math.sqrt(t); return new u(this.x * i, this.y * i) } } function d(t, i, s, o) { this.position = new u(t, i), this.mass = s, this.drag = o, this.force = new u(0, 0), this.velocity = new u(0, 0), this.AddForce = function (t) { this.force.Add(t) }, this.Integrate = function (t) { var i = this.CurrentForce(this.position); i.Div(this.mass); var s = new u(this.velocity.x, this.velocity.y); s.Mul(t), this.position.Add(s), i.Mul(t), this.velocity.Add(i), this.force = new u(0, 0) }, this.CurrentForce = function (t, i) { var s = new u(this.force.x, this.force.y), o = this.velocity.Length(), n = new u(this.velocity.x, this.velocity.y); return n.Mul(this.drag * this.mass * o), s.Sub(n), s } } function r(t, i) { this.pos = new u(t, i), this.rotationSpeed = 600 * Math.random() + 800, this.angle = l * Math.random() * 360, this.rotation = l * Math.random() * 360, this.cosA = 1, this.size = 5, this.oscillationSpeed = 1.5 * Math.random() + .5, this.xSpeed = 40, this.ySpeed = 60 * Math.random() + 50, this.corners = new Array, this.time = Math.random(); var s = Math.round(Math.random() * (p.length - 1)); this.frontColor = p[s][0], this.backColor = p[s][1]; for (var o = 0; o < 4; o++) { var n = Math.cos(this.angle + l * (90 * o + 45)), e = Math.sin(this.angle + l * (90 * o + 45)); this.corners[o] = new u(n, e) } this.Update = function (t) { this.time += t, this.rotation += this.rotationSpeed * t, this.cosA = Math.cos(l * this.rotation), this.pos.x += Math.cos(this.time * this.oscillationSpeed) * this.xSpeed * t, this.pos.y += this.ySpeed * t, this.pos.y > r.bounds.y && (this.pos.x = Math.random() * r.bounds.x, this.pos.y = 0) }, this.Draw = function (t) { 0 < this.cosA ? t.fillStyle = this.frontColor : t.fillStyle = this.backColor, t.beginPath(), t.moveTo(this.pos.x + this.corners[0].x * this.size, this.pos.y + this.corners[0].y * this.size * this.cosA); for (var i = 1; i < 4; i++)t.lineTo(this.pos.x + this.corners[i].x * this.size, this.pos.y + this.corners[i].y * this.size * this.cosA); t.closePath(), t.fill() } } function f(t, i, s, o, n, e, h, r) { this.particleDist = o, this.particleCount = s, this.particleMass = h, this.particleDrag = r, this.particles = new Array; var a = Math.round(Math.random() * (p.length - 1)); this.frontColor = p[a][0], this.backColor = p[a][1], this.xOff = Math.cos(l * e) * n, this.yOff = Math.sin(l * e) * n, this.position = new u(t, i), this.prevPosition = new u(t, i), this.velocityInherit = 2 * Math.random() + 4, this.time = 100 * Math.random(), this.oscillationSpeed = 2 * Math.random() + 2, this.oscillationDistance = 40 * Math.random() + 40, this.ySpeed = 40 * Math.random() + 80; for (var c = 0; c < this.particleCount; c++)this.particles[c] = new d(t, i - c * this.particleDist, this.particleMass, this.particleDrag); this.Update = function (t) { var i = 0; this.time += t * this.oscillationSpeed, this.position.y += this.ySpeed * t, this.position.x += Math.cos(this.time) * this.oscillationDistance * t, this.particles[0].position = this.position; var s = this.prevPosition.x - this.position.x, o = this.prevPosition.y - this.position.y, n = Math.sqrt(s * s + o * o); for (this.prevPosition = new u(this.position.x, this.position.y), i = 1; i < this.particleCount; i++) { var e = u.Sub(this.particles[i - 1].position, this.particles[i].position); e.Normalize(), e.Mul(n / t * this.velocityInherit), this.particles[i].AddForce(e) } for (i = 1; i < this.particleCount; i++)this.particles[i].Integrate(t); for (i = 1; i < this.particleCount; i++) { var h = new u(this.particles[i].position.x, this.particles[i].position.y); h.Sub(this.particles[i - 1].position), h.Normalize(), h.Mul(this.particleDist), h.Add(this.particles[i - 1].position), this.particles[i].position = h } this.position.y > f.bounds.y + this.particleDist * this.particleCount && this.Reset() }, this.Reset = function () { this.position.y = -Math.random() * f.bounds.y, this.position.x = Math.random() * f.bounds.x, this.prevPosition = new u(this.position.x, this.position.y), this.velocityInherit = 2 * Math.random() + 4, this.time = 100 * Math.random(), this.oscillationSpeed = 2 * Math.random() + 1.5, this.oscillationDistance = 40 * Math.random() + 40, this.ySpeed = 40 * Math.random() + 80; var t = Math.round(Math.random() * (p.length - 1)); this.frontColor = p[t][0], this.backColor = p[t][1], this.particles = new Array; for (var i = 0; i < this.particleCount; i++)this.particles[i] = new d(this.position.x, this.position.y - i * this.particleDist, this.particleMass, this.particleDrag) }, this.Draw = function (t) { for (var i = 0; i < this.particleCount - 1; i++) { var s = new u(this.particles[i].position.x + this.xOff, this.particles[i].position.y + this.yOff), o = new u(this.particles[i + 1].position.x + this.xOff, this.particles[i + 1].position.y + this.yOff); this.Side(this.particles[i].position.x, this.particles[i].position.y, this.particles[i + 1].position.x, this.particles[i + 1].position.y, o.x, o.y) < 0 ? (t.fillStyle = this.frontColor, t.strokeStyle = this.frontColor) : (t.fillStyle = this.backColor, t.strokeStyle = this.backColor), 0 == i ? (t.beginPath(), t.moveTo(this.particles[i].position.x, this.particles[i].position.y), t.lineTo(this.particles[i + 1].position.x, this.particles[i + 1].position.y), t.lineTo(.5 * (this.particles[i + 1].position.x + o.x), .5 * (this.particles[i + 1].position.y + o.y)), t.closePath(), t.stroke(), t.fill(), t.beginPath(), t.moveTo(o.x, o.y), t.lineTo(s.x, s.y), t.lineTo(.5 * (this.particles[i + 1].position.x + o.x), .5 * (this.particles[i + 1].position.y + o.y))) : i == this.particleCount - 2 ? (t.beginPath(), t.moveTo(this.particles[i].position.x, this.particles[i].position.y), t.lineTo(this.particles[i + 1].position.x, this.particles[i + 1].position.y), t.lineTo(.5 * (this.particles[i].position.x + s.x), .5 * (this.particles[i].position.y + s.y)), t.closePath(), t.stroke(), t.fill(), t.beginPath(), t.moveTo(o.x, o.y), t.lineTo(s.x, s.y), t.lineTo(.5 * (this.particles[i].position.x + s.x), .5 * (this.particles[i].position.y + s.y))) : (t.beginPath(), t.moveTo(this.particles[i].position.x, this.particles[i].position.y), t.lineTo(this.particles[i + 1].position.x, this.particles[i + 1].position.y), t.lineTo(o.x, o.y), t.lineTo(s.x, s.y)), t.closePath(), t.stroke(), t.fill() } }, this.Side = function (t, i, s, o, n, e) { return (t - s) * (e - o) - (i - o) * (n - s) } } u.Lerp = function (t, i, s) { return new u((i.x - t.x) * s + t.x, (i.y - t.y) * s + t.y) }, u.Distance = function (t, i) { return Math.sqrt(u.SqrDistance(t, i)) }, u.SqrDistance = function (t, i) { var s = t.x - i.x, o = t.y - i.y; return s * s + o * o + z * z }, u.Scale = function (t, i) { return new u(t.x * i.x, t.y * i.y) }, u.Min = function (t, i) { return new u(Math.min(t.x, i.x), Math.min(t.y, i.y)) }, u.Max = function (t, i) { return new u(Math.max(t.x, i.x), Math.max(t.y, i.y)) }, u.ClampMagnitude = function (t, i) { var s = t.Normalized; return new u(s.x * i, s.y * i) }, u.Sub = function (t, i) { return new u(t.x - i.x, t.y - i.y, t.z - i.z) }, r.bounds = new u(0, 0), f.bounds = new u(0, 0); var a = new (a = { Context: function (t) { var i = 0, s = document.getElementById(t), o = document.createElement("canvas"); o.width = s.offsetWidth, o.height = s.offsetHeight, s.appendChild(o); var n = o.getContext("2d"), e = new Array; for (f.bounds = new u(o.width, o.height), i = 0; i < 7; i++)e[i] = new f(Math.random() * o.width, -Math.random() * o.height * 2, 30, 8, 8, 45, 1, .05); var h = new Array; for (r.bounds = new u(o.width, o.height), i = 0; i < 25; i++)h[i] = new r(Math.random() * o.width, Math.random() * o.height); this.resize = function () { o.width = s.offsetWidth, o.height = s.offsetHeight, r.bounds = new u(o.width, o.height), f.bounds = new u(o.width, o.height) }, this.start = function () { this.stop(); this.interval = setInterval(function () { a.update() }, 1e3 / 30) }, this.stop = function () { clearInterval(this.interval) }, this.update = function () { var t = 0; for (n.clearRect(0, 0, o.width, o.height), t = 0; t < 25; t++)h[t].Update(1 / 30), h[t].Draw(n); for (t = 0; t < 7; t++)e[t].Update(1 / 30), e[t].Draw(n) } } }).Context("confetti"); a.start(), $(window).resize(function () { a.resize() }) });